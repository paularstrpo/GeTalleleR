#' Get Windows and V(pr) for a chromosome
#'
#' @param pos Integer or Numeric vector with genomic positions within the same chromosome to segment.
#' @param vaf Numeric vector of VAFs (variant allele frequencies) for a given layer. Must correspond to sites in pos.
#' @param seg_start An integer or numeric value. Where to start segmentation? Default is 1 (the start of the chromosome).
#' @param seg_end An integer or numeric value. Where to end segmentation? Default (0) uses the maximum value of `pos`.
#' @param sensitivity A number. Penalty value for segmentation via `changepoint::cpt.meanvar`
#' @param models_cdf A numeric vector containing the cumulative density for a VAF model generated by `gen_ideal_hist()`
#' @return a DF or list with information about windows and the vafs for SNPs within each window. (TODO: flesh this doc out more)
calc_window_vpr <- function(pos, vaf, seg_start=1, seg_end=0, sensitivity=0.2,
                            bin_edges, models_cdf){
    # The authors make no representations about the suitability of this software
    # for any purpose. It is provided "as is" without express or implied warranty.

    # First, get windows using find_windows()
    win_res <- find_windows(pos=pos, vaf = vaf,
                            sensitivity = sensitivity,
                            seg_start = seg_start,
                            seg_end = seg_end)

    # compute V(pr) for each window
    fitted_vprs <- lapply(win_res$result, function(x){
        # get vpr for each layer using fit_vpr.r
        fit_vpr(x = (abs(x$vaf-0.5)+0.5), models = models_cdf, bin_edges = bin_edges)
    })

    # TODO: change to return a df of layer + positons in each segments
    # [sorted_fitted_vprs, idx_sorted] <- order(fitted_vprs) # leftover matlab code

    # if : segment difference between V(pr)s in segment is less than a threshold of 0.011
    # then: combine segment with the previous one.
    d_fitted_vprs <- diff(sorted_fitted_vprs)
    idx_same_vprs <- which(d_fitted_vprs <= 0.011)

    while (!is.na(idx_same_vprs)){
        # step 1: combine segments that fail the threshold with their predecessors.
        for (i in idx_same_vprs)){
            m(i).win_data <- [m(i).win_data; m(i+1).win_data]
            m(i).window <- [m(i).window m(i+1).window]
            m(i).win_bp_length <- m(i).win_bp_length+m(i+1).win_bp_length
            idx_rm(i) <- i+1
        }

        # step 2
        for (i in 1:nrow(m)){
            # folded_m <- abs(m(i).win_data(:,layer+1)-0.5)+0.5 # change to use layer map convention
            fitted_vprs(i) <- fit_vpr(folded_m,models_mat(layer).models,bin_edges)
        }

        # [sorted_fitted_vprs, idx_sorted] <- order(fitted_vprs)
        # m <- m[idx_sorted, ]

        # re-assess threshold for reducing segment size
        d_fitted_vprs <- diff(sorted_fitted_vprs)
        idx_same_vprs <- which(d_fitted_vprs <= 0.011)
    }

# Fit V(pr) after segmentation and compare to other layers - code
# This loop iterates over all the segments that were found to check:
#  - how many samples
#  - length of segment in terms of a) num points and b) genomic length
for (i in 1:length(win_res$result)){
    win_res$win_dp_length(i) <- numel(folded_m) # keep this
    win_res$win_bp_length(i) <- m(i).win_bp_length # keep this
    win_res$fitted_vprs[[i]] <- fit_vpr(folded_m, models_mat(k).models,bin_edges)
    }
