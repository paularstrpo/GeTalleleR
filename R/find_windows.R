# find_windows

#' Get Windows and V(pr) for a chromosome
#'
#' @param pos Integer or Numeric vector with genomic positions (within the same chromosome) to segment.
#' @param vaf Numeric vector of VAF (variant allele frequencies) for a given layer. Must correspond to sites in pos.
#' @param seg_start Where to start segmentation? Default is 1.
#' @param seg_end Where to end segmentation? Default is the maximum value of `pos`.
#' @param sensitivity Parameter for segmentation via findchangepoints
#' @param models_cdf cumulative density for a VAF model generated by gen_ideal_hist
#' @return a DF or list with the information: chromosome | layer_name | seg_start |  seg_end | genomic_length | num_sites | merged_window_idx | merged_window_start | merged_window_end | V(pr)

# TODO: adapt functions to be able to take a user-specified number of layers
# perhaps take a layer_map argument that is a named character vector...

find_windows <- function(pos, vaf, seg_start=1, seg_end=NULL, sensitivity=0.2,
                             model_cdf, model_dist, bin_edges){
    # The authors make no representations about the suitability of this software for any purpose.
    # It is provided "as is" without express or implied warranty.


    # set up results list
    res <- list()

    # data on the chromosome containing the segment of interest
    data <- data.frame(pos=pos, vaf=vaf) # data is a matrix with base-pairs and all layers
    rm(pos, vaf)

    # if seg_end is not specified then use the largest positional value in the dataset.
    if (is.null(seg_end)){
        seg_end <- max(as.numeric(data$pos))
    }

    # Grab data in the segment we are looking at
    seg_filt <- (data$pos >= seg_start) & (data$pos <= seg_end)

    if (length(data$pos[seg_filt])==0){
        return(print('Error: specified segment has zero sites.'))
    }

    # processeing of segments with no data
    data_sgmnt <- data[seg_filt,] # trim data to fit specified segment
    ds_size <- nrow(data_sgmnt) # length of segment in terms of sites


    # GENERATION OF WINDOWS

    # could instead set 'MinDistance', Lmin, to 11 ponints
    iptsT <- cpt.meanvar(abs(data_sgmnt$pos-0.5)+0.5, penalty='Manual', pen.value=sensitivity)
    # grab indeces for window edges
    idx_all_edges <- c(seg_start, iptsT@cpts[1:iptsT@ncpts.max], ds_size)

    # merge windows with less than a threshold number of points (or a threshold Vpr)
    idx_gap <- diff(idx_all_edges<10)
    # always keep the start point and merge with the second window instead
    if (idx_gap[1]==1){
        idx_gap[1] <- 0
        idx_gap[2] <- 1
    }

    # grab indeces for window starts & ends
    idx_win_start <- idx_all_edges[1:length(idx_all_edges)-1]
    idx_win_end <- idx_all_edges[2:length(idx_all_edges)]

    # save window information
    m <- data.frame(window_start=data$pos[idx_win_start],
                    window_end=data$pos[idx_win_end])

    # genomic length of window
    m$window_bp_length <- m$window_end - m$window_start
    # length in terms of number of SNPs residing in the window
    # m$window_site_length <-
    # append layer vafs

    res <- list(segment_inputs=data_sgmnt,
                total_length=ds_size,
                total_bp_length=end_pos-start_pos,
                num_windows=nrow(m),
                window_data=m)

    return(res)
}
