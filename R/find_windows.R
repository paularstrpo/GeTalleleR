# find_windows

#' Get Windows and V(pr) for a chromosome
#'
#' @param pos Integer or Numeric vector with genomic positions (within the same chromosome) to segment.
#' @param vaf Numeric vector of VAF (variant allele frequencies) for a given layer. Must correspond to sites in pos.
#' @param seg_start Where to start segmentation? Default is 1.
#' @param seg_end Where to end segmentation? Default is the maximum value of `pos`.
#' @param sensitivity Parameter for segmentation via findchangepoints
#' @param models_cdf cumulative density for a VAF model generated by gen_ideal_hist
#' @return a DF or list with the information: chromosome | layer_name | seg_start |  seg_end | genomic_length | num_sites | merged_window_idx | merged_window_start | merged_window_end | V(pr)

# TODO: adapt functions to be able to take a user-specified number of layers
# perhaps take a layer_map argument that is a named character vector...

find_windows <- function(pos, vaf, seg_start=1, seg_end=NULL, sensitivity=0.2,
                             model_cdf, model_dist, bin_edges){
    # The authors make no representations about the suitability of this software for any purpose.
    # It is provided "as is" without express or implied warranty.


    # set up results list
    res <- list()

    # data on the chromosome containing the segment of interest
    data <- data.frame(pos=pos, vaf=vaf) # data is a matrix with base-pairs and all layers
    rm(pos, vaf)

    # if seg_end is not specified then use the largest positional value in the dataset.
    if (is.null(seg_end)){
        seg_end <- max(as.numeric(data$pos))
    }

    # Grab data in the segment we are looking at
    seg_filt <- (data$pos >= seg_start) & (data$pos <= seg_end)

    if (length(seg_filt[seg_filt])==0){
        return(print('Error: specified segment has zero sites.'))
    }

    # processeing of segments with no data
    data_sgmnt <- data[seg_filt,] # trim data to fit specified segment
    ds_size <- nrow(data_sgmnt) # length of segment in terms of sites


    ########## GENERATION OF WINDOWS ##########
    smpl <- data_sgmnt[, 2]
    # could instead set 'MinDistance', Lmin, to 11 ponints
    iptsT <- cpt.mean(abs(smpl-0.5)+0.5, penalty='Manual', pen.value=sensitivity, class=FALSE)

    idx_all_edges <- c(1, t(iptsT), ds_size)
    idx_gap <- diff(idx_all_edges)<10){

        # always keep the start point and merge with the second window instead
        if (idx_gap(1)==1){
            idx_gap(1) <- 0
            idx_gap(2) <- 1
        }

    idx_all_edges(idx_gap) <- []
    idx_win_start <- idx_all_edges(1:}-1)
    idx_win_} <- [idx_all_edges(2:}-1)-1 ds_size]

    nb_of_windows <- numel(idx_win_start)
    ########## PUT DATA FROM WINDOWS INTO A STRUCTURE ##########
    m <- struct([])
    for (i in 1:nb_of_windows){
        idx_window <- idx_win_start(i):idx_win_}(i)
    m(i).win_data <- data_sgmnt(idx_window,:) # position, vafs as layers, changepoints
    m(i).window <- idx_window
    m(i).win_bp_length <- m(i).win_data(},1)-m(i).win_data(1,1)
    }


    res <- list(segment=data_sgmnt,
                    total_length=ds_size,
                    total_bp_length=end_pos-start_pos
                    )

    return(res)


}
